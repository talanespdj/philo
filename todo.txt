https://www.geeksforgeeks.org/thread-functions-in-c-c/
https://www.geeksforgeeks.org/condition-wait-signal-multi-threading/?ref=next_article

https://www.youtube.com/playlist?list=PLfqABt5AS4FmuQf70psXrsMLEDQXNkLq2

https://github.com/koekeishiya/yabai
app pour gerer les windows sur mac

[✅]= gerer le cas ou il n'y a qu'un seul philo

[✅]= ajouter l'utilisation du write_mtx qui est accesssible à chaque phl[i] via
		un pointeur *write_mtx dans chaque struct de philo

[✅]= si la derniere fois qu'il a mange > tt_die 
	phl[n]->lastteating - ttime(p) > phl->tt_die 

[ ]= arrêter le programme lorsqu'un philo meurt

[ ]= possible deadlock lorsqu'un philo meurt, que dans ma fonction surveil je vais chercher les mtx de chaque philo
		pour set plh->health = dead, si le mtx du philo est deja pris boucle infini 
		analyser avec les WHATS HAPPENING philo->id



[ ]= 				PROBLEME A GERER YGTHIS


./philo 6 500 200 200 // 

	0 2 has taken a fork
	0 2 has taken a fork
	0 2 is eating	lastteating // 0
	1 4 has taken a fork
	1 4 has taken a fork
	1 4 is eating	lastteating // 1
	1 6 has taken a fork
	1 6 has taken a fork
	1 6 is eating	lastteating // 1
	200 2 is sleeping
	201 6 is sleeping
	201 1 has taken a fork
	201 1 has taken a fork
	201 1 is eating	lastteating // 201  // ici le time_t lastteating du philo est reset a 201
	201 4 is sleeping
	201 5 has taken a fork
	201 5 has taken a fork
	201 5 is eating	lastteating // 201
	201 3 has taken a fork
	201 3 has taken a fork
	201 3 is eating	lastteating // 201
	401 5 is sleeping
	401 3 is sleeping
	401 1 is sleeping
			501 1 died // lastteating 0	tt_die // 500 
	/// mais pour la fonction surveil qui verifie l'instant t - lastteating > tt_die, lastteating = 0
		///	alors que dans ma fonctione eat lastteating est set a 201 quand le mutex est lock
				t = 501


 pthread_detach // pthread_join // pthread_mutex_init 
		pthread_mutex_destroy //pthread_mutex_lock // pthread_mutex_unlock

dont forget tout erase everything in Makefile
